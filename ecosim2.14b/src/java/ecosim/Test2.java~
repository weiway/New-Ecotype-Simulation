package ecosim;

import java.util.*;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.FileReader;
import java.io.IOException;

public class Test2{ 

  public static void main(String[] args) throws IOException, InvalidNewickException{
    String tree = new Scanner(new File("ecosim/short.nwk")).useDelimiter("\\z").next();
    System.out.println(tree);
    NewickTree Ntree = new NewickTree(tree);
    NewickTreeNode primary_node = new NewickTreeNode();
    NewickTreeNode sister_node = new NewickTreeNode();
    String strain = "M7C7";
    primary_node = find_node_with_taxon_label(strain,Ntree);
    System.out.println(primary_node.toString());
    sister_node = sister_nodes(primary_node);
    System.out.println(sister_node.toString());
    
    
    List<List<String>> lst = new ArrayList<List<String>>();
    lst = down_search(primary_node, 0, lst);
    System.out.println(lst);
    
    
    System.out.print(closest_relative(Ntree, "M7C7"));
    System.out.println(" hello");
  }
  /**
   * Returns the NewickTreeNode with the specified taxon label in the given tree.
   * 
   * @param strain Name of strain being searched for.
   * @param tree Newick formatted tree to search down.
   * @return NewickTreeNode containing the wanted strain from the Newick formatted tree.
   */
    private static NewickTreeNode find_node_with_taxon_label(String strain, NewickTree tree){
        NewickTreeNode nodeFound = new NewickTreeNode();
        List<NewickTreeNode> descendants = tree.getDescendants();
        for (int i = 0; i < descendants.size(); i++){
            NewickTreeNode descendant = descendants.get(i);
            if (descendant.getName().equals(strain)) {
                 nodeFound = descendant;
                 break;
            }
        }
        return nodeFound;
    }
    
  /**
   * Returns the sister of the NewickTreeNode given.
   * 
   * @param primary_node NewickTreeNode to find the sister of.
   * @return NewickTreeNode containing the sister of the node given.
   */
  private static NewickTreeNode sister_nodes(NewickTreeNode primary_node){
      NewickTreeNode sister_found = new NewickTreeNode(); 
      NewickTreeNode parent_node = primary_node.getParent();
      List<NewickTreeNode> children = parent_node.getDescendants();
      for (int i = 0; i < children.size(); i++){
        NewickTreeNode child = children.get(i);
        if (!child.getName().equals(primary_node.getName())){
          sister_found = child;
          break;
        }
      }
      return sister_found;
    }
  
  /**
   * Returns a sorted list of [[name,distance],[name2,distance2]] based on distance.
   * 
   * @param node NewickTreeNode containing the beginning node to search?
   * @param dist Integer containing the distance from the original node.
   * @param lst List<List<String>> containing [[name,distance]]
   * @return List<List<String>> containing [[name,distance]]
   */
  private static List<List<String>> down_search(NewickTreeNode node, Integer dist, List<List<String>> lst){
      if(node.isLeafNode()){
        List<String> pair = new ArrayList<String>();
        pair.add(node.getName());  
        pair.add(String.valueOf(dist));
        // removed from list?
        lst.add(pair);
        return lst;
        //return lst.add(pair)
      }
      else {
        dist = dist + 1;
        List<List<String>> down = new ArrayList<List<String>>();
        List<NewickTreeNode> children = node.getDescendants();
        NewickTreeNode child1 = children.get(0);
        NewickTreeNode child2 = children.get(1);
      
        List<String> pair1 = new ArrayList<String>();
        pair1.add(child1.getName());  
        pair1.add(String.valueOf(dist));
        //name.remove(0);
        lst.add(pair1);
        down_search(child1, dist, lst);
        
        List<String> pair2 = new ArrayList<String>();
        pair2.add(child2.getName());  
        pair2.add(String.valueOf(dist));
        lst.add(pair2);
        down_search(child2, dist, lst);
        
        // may or may not have to flatten
        Collections.sort(lst, new Comparator<List<String>> () {
          public int compare(List<String> a, List<String> b) {
            return a.get(1).compareTo(b.get(1));
          }
        });
        return lst;
      }
  }
  
  /**
   * Returns a sorted list of [[name,distance],[name2,distance2]] based on distance, 
   * indicating the closest relatives.
   * 
   * @param tree Newick formatted tree to search.
   * @param strain Name of the strain's relatives to find.
   * @return List<List<String>> containing [[name,distance]] in order of closest relatives. 
   */
  private static List<List<String>> closest_relative(NewickTree tree, String strain){
      NewickTreeNode primary_node = find_node_with_taxon_label(strain, tree);
      if((primary_node.getName()).equals("")){
        System.out.println("PRIMARY node " + strain + "could not be found in the tree");
        return null;
      }
      if (primary_node.isLeafNode()){
        NewickTreeNode sister_node = sister_nodes(primary_node);
        List<List<String>> lst = new ArrayList<List<String>>();
        return down_search(sister_node,0,lst);
      }
      else{
        System.out.println("PRIMARY node " + primary_node + " is NOT a leaf!");
        return null;
      }
    }
}
